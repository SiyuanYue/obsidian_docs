
# 现有实现
```ts
type ConcurrentHashMapBucket<K, V> = ConcurrentHashMapBucketImpl<K, V> | undefined;

export class ConcurrentHashMap<K, V> implements ReadonlyMap<K, V>{
private buckets: ConcurrentHashMapBucket<K, V>[] = []; 
private mutex: Object = ConcurrencyHelpers.mutexCreate();
private condVar: Object = ConcurrencyHelpers.condVarCreate(); // 控制setVal的条件变量
private sizeVal: AtomicsCounter = new AtomicsCounter(0);
private setVal: AtomicsCounter = new AtomicsCounter(0);

private static readonly ENTRY_KEY = 0;
private static readonly ENTRY_VAL = 1;

private static readonly MIN_BUCKETS_COUNT = 8;
}
```

- bucketMutex：保护对 `buckets` 数组的读写。
- recreateMutex：在创建或更新 `bucketMutex` 数组时使用。


`$_hashCode() : int`   
`getBucekteIndex` ~ Java 用 `(tab.length-1)& spread(key.hashCode())`  的方式获得该key的hash值对应的桶的索引

```ts
private getBucketIndex(k: NullishType): int {
    if (k === null) {
        return 0;
    }
    if (k === undefined) {
        return 1;
    }

    const keyHash: int = k!.$_hashCode();
    const t = keyHash >> 31; //右移 31 位获取符号位

    return ((keyHash ^ t) - t) & (this.buckets.length - 1); //获得hashcode的绝对值然后对桶数取余获得bucketIndex
}
```
也许 不用implements ReadonlyMap  ？或者ConcurrentHashMap保留，但ConcurrentSet不用 implements ReadonlySet

把获取hash绝对值 `getAbsHashCode()` 与 获取索引 `getBucketIndex()`

设置容量，初始/预置为2的倍数

# ConcurrentHashMap重构方案
## 实现细节
### **数据存储**方面：
- 一个bucket：MapNode 作为head/root 
	- `链表/TreeNode`   ? ~~treenode 红黑树？ 简易红黑树需要如何实现~~ 经分析，非主要与核心负载场景，暂不处理，就只采用链表，可以在设计上留足空间。定一个MapNode 基类，我们先只有LinkedNode 一个实现类，红黑树等HashMap那边迁移动作之后再说。
	- `class LinkedNode<K,V> implements MapNode<K,V>`
	- `class TransferNode<K,V> implements MapNode<K,V>`
	- `MapNode`类一个属性为该bucket的锁，但这样每个链表都有会占据内存

- `MapEntry` 存储key/value值，有getkey与getvalue method。
- buckets :` MapNode[]` or `Array<MapNode>`  
	- Bucket要单独作为一个类存在吗，持有一个Node和一个锁？

```ts
interface MapEntry<K,V>{
	key: K;
	value: V;
	hashValue: int;
	public getKey(): K ;
	public getValue(): V;
 	
 	get hash(): int ;  // need
 	equals(Object O): boolean ; // ArkTS1.2有类似equals的东西吗
 	//setValue(value: V): V|undefined ;  // not used in ConcurrentHashMap
  	toString(): String{
  		...
  	}
  }
}
class MapNode<K,V> implements MapEntry<K,V>{
	public next: MapNode<K, V>|undefined = this;  // 我们有或者需要类似java volatile的东西吗
	public isTransfered: boolean =false;
	
	constructor(key: K, val: V) {
	this.key = key;
	this.val = val;
	
	...
	}

```
>[!java]
>- **`hashCode` 方法**：使用与 `equals` 中相同的关键字段生成哈希值，确保相等的对象具有相同的哈希码。
>- `eaquals`: `Object` 类中的默认实现使用的是引用相等，即两个对象只有在内存地址相同时才被认为是相等的。    
>- **重写 `equals`**  
  >    - 你需要按照对象的内容（而不仅仅是引用）来判断相等时，就需要在自己的类中重写 `equals` 方法。比如，在一个表示“人”的类中，可能希望比较人的姓名、年龄等属性是否相等。
 
我们`$_hashCode` 与 属性hashValue 与 bucketIndex之间的关系

### 无锁原子读写
`buckets: Bucket<K,V>[]`
读写的对象是**buckets** 数组的某一个元素
```ts

class Bucket<K,V>{
	head: MapNode<K,V>;
	mutex: Object;
	isTransfer: boolean; //是否迁移
}

readBucket(buckets: Bucket<K,V>[], index:int);
setBucket(buckets: Bucket<K,V>[], index:int , newVal: MapNode<K,V>);
casBUcket(buckets: Bucket<K,V>[], index:int , compareVal: MapNode<K,V> , newVal: MapNode<K,V>);
```
把需要原子读写的地方先抽象成一个函数，然后内部暂时使用锁来实现，并在前面注释上之后考虑用`Atomic` 无锁的方式来实现, 得留下修改的空间。

> Runtime侧 `EtsPrimitiveArray` 继承 `EtsArray` 继承 `Array`
与`BuiltinArray`的关系


### 锁的粒度
锁应该放到bucket伴生类内？
> java 是用 synchronized(f)实现的，所以不需要对头结点显式的地定义一把锁
###  `foreach`的处理？

### Java 一致性？ 快照`SnapShot`处理？

### Java 扩容、Transfer处理 & Help Transfer?   

### 代码规范
注释详细些，尤其是对于每个函数前面，可以详细描述这个函数的功能，包括不export的，因为ConcurrentHashMap比较复杂，之后有可能扩展和修改。

### 测试用例验证
无视 ic!=nullptr类型错误，这是jit-repeats重复测试与taskpool.execute冲突导致。
```
cd /path/to/static_core/tests

sudo ./runner.sh --ets-func-tests --build-dir="/home/panlf/runtime_code/arkcompiler1/runtime_core/static_core/out" --processes=16 --work-dir=/home/panlf/runtime_code/arkcompiler1/runtime_core/static_core/plugins/ets/tests/ets_func_tests --heap-verifier=fail_on_verification:pre:into:before_g1_concurrent:post --es2panda-timeout=90 --timeout=1300 --ark-args="--compiler-ignore-failures=false" --jit --jit-preheat-repeats="num_repeats=5000" --force-generate --compare-files-iterations=2  --chapter std-containers-ConcurrentHashMap-dir
```

## benchmark
测试性能
对比Java  ：
  - 均为3个线程/`EAWorker`对比
  - ~~ark 这边20个coro， java 这边20个线程~~

