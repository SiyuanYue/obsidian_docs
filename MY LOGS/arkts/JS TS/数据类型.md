## **JavaScript 数据类型**
JavaScript 共有 **七种基本数据类型** 和 **一种引用类型**。

### **1. 基本数据类型（Primitive Types）** pass value
基本数据类型存储在 **栈（Stack）** 内存中，按值存储，赋值和传递时 **拷贝值**。
>[!type]
> - `string`（字符串）
>- `number`（数字，包括 `NaN`、`Infinity`）
>- `bigint`（大整数）
>- `boolean`（布尔值）
>- `undefined`（未定义）
>- `null`（空值）
>- `symbol`（唯一标识符）

**示例**
```javascript
let a = 10;
let b = a; // 复制了 a 的值
b = 20; 
console.log(a); // 10（a 不受 b 影响）
```

---

### **2. 引用数据类型（Reference Types）** pass reference
引用类型存储在 **堆（Heap）** 内存中，变量存储的是 **地址（引用）**，赋值和传递时 **拷贝引用**。

包括：
- `Object`（对象）
- `Array`（数组）
- `Function`（函数）
- `Date`（日期）
- `RegExp`（正则表达式）
- 其他派生对象（如 `Map`、`Set`、`WeakMap`、`WeakSet`）

**示例**
```javascript
let obj1 = { name: "Alice" };
let obj2 = obj1; // obj2 复制了 obj1 的地址
obj2.name = "Bob"; 

console.log(obj1.name); // "Bob"（obj1 和 obj2 指向同一个对象）
```

---

## **值传递（Pass by Value） vs. 引用传递（Pass by Reference）**
JavaScript **没有真正的“按引用传递”（Pass by Reference）**，它只有 **按值传递（Pass by Value）**，但对于**对象**类型，传递的是 **引用的拷贝**，所以看起来像是按引用传递。

### **1. 传递基本类型（按值传递）**
基本类型变量直接存储值，函数参数传递时 **拷贝值**，不会影响原变量。
```javascript
function changeValue(x) {
    x = 20;
    console.log(x); // 20
}

let a = 10;
changeValue(a);
console.log(a); // 10（原变量不受影响）
```

---

### **2. 传递引用类型（按引用值传递）**
引用类型变量存储的是对象的地址，函数传递时 **拷贝这个地址**，所以**修改对象内容会影响原对象**。
```javascript
function changeObject(obj) {
    obj.name = "Charlie";
}

let person = { name: "Alice" };
changeObject(person);
console.log(person.name); // "Charlie"（原对象被修改）
```

---

### **3. 赋新对象（不会影响原对象）**
如果在函数内部为参数赋了一个新对象，原对象不会被修改：
```javascript
function changeReference(obj) {
    obj = { name: "David" }; // 重新赋值，新对象不会影响外部
}

let person = { name: "Alice" };
changeReference(person);
console.log(person.name); // "Alice"（原对象未改变）
```
这里 `obj = { name: "David" }` 只是改变了 `obj` 的指向，而 **不会改变外部 `person` 变量的引用**。

---

## **总结**
| **类型** | **存储位置** | **赋值时** | **函数参数传递时** |
|---------|------------|----------|--------------|
| 基本类型 | **栈** | 复制值 | **拷贝值**（不会影响原变量） |
| 引用类型 | **堆**（变量存的是引用） | 复制引用地址 | **拷贝引用**（会影响原对象） |

### **核心结论**
- **基本类型** 赋值或传递参数时，会拷贝值，不影响原变量。
- **引用类型** 赋值或传递参数时，会拷贝引用地址，修改对象内容会影响原变量。
- **但如果在函数内部重新赋值一个新对象，则不会影响原变量**。

如果想让对象不被修改，可以使用 **深拷贝** 或 **冻结对象**：
```javascript
let obj = { name: "Alice" };
Object.freeze(obj);
obj.name = "Bob"; // 无效
console.log(obj.name); // "Alice"
```

---

Also of note, the use of `public` on parameters to the constructor is a shorthand that allows us to automatically create properties with that name.  
此外，在构造函数参数中使用 `public` 是一种缩写，允许我们自动创建具有该名称的属性。

```ts
class Student {
  fullName: string;
  constructor(
    public firstName: string,
    public middleInitial: string,
    public lastName: string
  ) {
    this.fullName = firstName + " " + middleInitial + " " + lastName;
  }
}
```

这里构造函数的参数里的 public 就使 Student 类多了三个属性。
