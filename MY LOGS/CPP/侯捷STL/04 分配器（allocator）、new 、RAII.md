
## 先复习一下 new 运算符

![[new]]

---

`new` 是 C++中的一个关键字，用于在动态内存中创建对象。通过 `new` 运算符，我们可以在堆（heap）上分配内存，并返回指向该内存的指针。它可以用于创建单个对象、数组以及动态分配的类对象。

`new` 运算符有两种基本格式：
1. 创建单个对象：`new T` 或 `new T()`，其中 `T` 是要创建对象的类型。这会在堆上分配内存，并调用对象的默认构造函数初始化对象。
2. 创建数组：`new T[N]`，其中 `T` 是要创建对象的类型，`N` 是数组的大小。这会在堆上分配 `N` 个 `T` 类型的对象的内存，并调用每个对象的默认构造函数进行初始化。

`new` 运算符的返回值是一个指向分配的内存的指针，如果分配失败，则返回一个 `std::bad_alloc` 异常。

`new` 运算符还可以与 `delete` 运算符结合使用，用于释放通过 `new` 动态分配的对象。例如：
- 释放单个对象：`delete ptr`，其中 `ptr` 是通过 `new` 创建的对象的指针。
- 释放数组对象：`delete[] arr`，其中 `arr` 是通过 `new` 创建的数组的指针。

需要注意的是，通过 `new` 分配的对象在不再被使用时，应该使用 `delete` 或 `delete[]` 进行释放，以防止内存泄漏。

new 创建的对象是*默认初始化*的，类类型对象使用默认构造函数进行初始化。
>默认初始化规则：
>C++有一套默认初始化规则，用于确定在没有显式初始化对象时，对象将如何被初始化。这些规则根据对象的类型不同而有所不同。下面是关于 C++默认初始化规则的详细介绍：
>1. 内置类型（如 `int`、`float`、`char` 等）：如果内置类型的对象没有被显式初始化，它们的值将是未定义的，也就是任意的。这是因为内置类型的对象通常在栈或静态存储区中分配，而不是在堆中动态分配。为了避免使用未初始化的内置类型对象，建议在使用之前进行显式初始化。
>2. 类类型（如自定义的类、结构体、类模板等）：如果类类型的对象没有被显式初始化，它们的成员将按照以下规则进行初始化：
   如果类有默认构造函数，则会调用默认构造函数来初始化每个成员。
   如果类没有默认构造函数，但是有提供初始化的构造函数，则必须通过成员初始化列表（member initializer list）在对象的定义中进行初始化。
   如果类既没有默认构造函数，也没有提供初始化的构造函数，并且在对象的定义中没有进行初始化，则会引发编译错误。
  3. 数组：如果数组没有被显式初始化，则以下规则适用：声明为静态存储区（如全局变量）的数组将被默认初始化为零值（如果是内置类型）或默认构造函数的调用（如果是类类型）。声明为自动存储区（如函数内的局部变量）的数组将不会被默认初始化，其元素的值是未定义的。

>需要注意的是，如果你使用了构造函数或成员初始化列表来显式初始化对象，那么默认初始化规则将不再适用。显式初始化将覆盖默认初始化。
>总结起来，C++的默认初始化规则决定了当对象没有被显式初始化时，对象将如何被初始化。对于内置类型，未初始化的对象的值是未定义的。对于类类型和数组，未初始化的对象将调用默认构造函数进行成员初始化，或者通过成员初始化列表显式初始化。在使用对象之前，请确保对象已经被显式初始化，以避免出现未定义的行为。

---
除了默认构造函数外，`new` 运算符还可以与自定义的构造函数和析构函数一起使用，在分配内存时调用相应的构造函数进行初始化，在释放内存时调用析构函数清理资源。
例如 `string *ps=new string(10,'9');`
总结起来，`new` 运算符是 C++中用于在动态内存中创建对象的关键字。它可以在堆上分配内存，并调用构造函数初始化对象。使用 `delete` 运算符可以释放通过 `new` 动态分配的对象。这样，我们可以在运行时动态地管理对象的生命周期和内存分配。

通过提供初始化器的方式使用 new
```C++
auto p1=new auto(obj);
```
`p1` 是指向从 `obj` 自动推断出的类型的指针。

> 注意 new 和 delete 是运算符，是可以重载的哦！

## 所有权：RAII 觉醒与 new

我们知道对象的生存期由其范围决定。但是，有时我们需要创建一个对象，该对象与创建对象的作用域无关，这是有用的，或者很有用。在 C ++中，*运算符 new*用于创建这样的对象。为了销毁对象，可以使用*运算符 delete*。由 new 操作员创建的对象是*动态分配*`（=>堆）` 的，即在动态内存（也称为堆或空闲存储）中分配。因此，由 new 创建的对象将继续存在，直到使用 delete 将其明确销毁为止。


使用new和delete时可能发生的一些错误是：

- 对象（或内存）泄漏：使用new分配对象，而忘记删除该对象。
    
- 过早删除（或悬挂引用）：持有指向对象的另一个指针，删除该对象，然而还有其他指针在引用它。
    
- 双重删除：尝试两次删除一个对象。


通常，范围变量是首选。 但是，**RAII**可以用作new和delete的替代方法，以使对象独立于其范围而存在。 *这种技术包括将指针分配到在堆上分配的对象，并将其放在句柄/管理器对象中。 后者具有一个析构函数，将负责销毁该对象*。 **这将确保该对象可用于任何想要访问它的函数，并且该对象在句柄对象的生存期结束时将被销毁，而无需进行显式清理。**

来自 C ++标准库的使用 RAII 的示例为 std :: string 和 std :: vector
```C++
void fn(const std::string& str) { std::vector<char> vec; for (auto c : str) vec.push_back(c); // do something }
```
当创建 `vector`, 并将元素推入 `vector` 时，您不必担心分配和取消分配此类元素内存。 `vector` 使用 new 为其堆上的元素分配空间，并使用 delete 释放该空间。作为 vector 的用户，您无需关心实现细节，并且会相信 vector 不会泄漏。在这种情况下，向量是其元素的句柄对象。
标准库中使用 RAII 的其他示例是 `std :: shared_ptr`，`std :: unique_ptr` 和 `std :: lock_guard`。

该技术的另一个名称是 SBRM，是范围绑定资源管理的缩写。
## STL 中这种操作是怎么实现的呢 ？=> ALLOCATOR
>看看 chatGPT 怎么说的吧：
>C++中的 `allocator` 是一个用于分配和释放内存的模板类，它在动态内存管理中起到了重要的作用。`allocator` 模板类提供了两个主要的函数：`allocate` 和 `deallocate`，用于分配和释放内存。
>另一方面，`new` 是 C++中的一个关键字，用于动态地分配内存并创建对象。通过 `new` 运算符，我们可以在堆上创建对象，并返回指向该对象的指针。`new` 运算符可以自动调用适当的构造函数来初始化对象。
> `allocator` 与 `new` 之间的关系是，`allocator` 可以被用于自定义实现对象的内存分配策略。我们可以根据自己的需求，通过实现自己的 `allocator` 模板类，在其中使用 `new` 来进行内存分配。这样，我们就可以控制对象的内存分配方式，例如使用自定义的内存池，或者实现特定的内存对齐要求。
>总而言之，`allocator` 是一个模板类，用于分配和释放内存，而 `new` 是 C++中的关键字，用于动态地分配内存并创建对象。`allocator` 可以自定义内存分配策略，并在其中使用 `new` 来分配内存。

再次提示：
> 注意 new 和 delete 是运算符，是可以重载的哦！

## 分配器 
- new 之下其实可能是 malloc
![[Pasted image 20230709174300.png]]
- 标准（简单来讲） allocator 其实就是用了 `:operater new` 。
![[Pasted image 20230709174349.png]]
`int *p =allocator<int>().allocator(512,(int *(0));` 用一个临时对象 `allocate`.
`allocator<int>().deallocate(p,512)`
分配器在回收时要指明分配的数量，所以对我们来说，根本并不好用，但是给容器来使用没有问题。

---
在 C++标准库中，`allocate` 函数有一个重载版本，该版本接受一个额外的参数 `count`，用于指定要分配的对象数量。

函数签名如下：

```
pointer allocate(size_type n, const_void_pointer hint);
```

`count`参数表示要分配的对象数量，`hint`参数是一个指向常量类型的指针，表示一个分配的提示或者是一个已经分配的内存空间的地址。

这个参数的作用是可以提供一个提示，帮助内存分配器更好地选择分配内存的策略。然而，这个参数的具体行为是依赖于实现的，不同的编译器和标准库实现可能会有不同的处理方式。

尽管`hint`参数提供了一个提示，但在实践中，并不是所有的情况下都能被内存分配器有效利用。因此，很多情况下我们可以将`hint`参数设置为`nullptr`，以使用默认的分配策略。

以下是一个示例，展示了如何使用带有`hint`参数的`allocate`函数：

```
#include <iostream>
#include <memory>

int main() {
  std::allocator<int> alloc;  // 创建一个 int 类型的分配器对象

  int* ptr = alloc.allocate(5, nullptr);  // 分配 5 个 int 类型的内存空间

  for (int i = 0; i < 5; i++) {
    *(ptr + i) = i + 1;
  }

  for (int i = 0; i < 5; i++) {
    std::cout << *(ptr + i) << " ";
  }

  alloc.deallocate(ptr, 5);  // 释放内存空间

  return 0;
}
```

在上述示例中，我们使用`allocate`函数同时传递了`count`和`hint`参数，其中`count`指定为5，`hint`参数设置为`nullptr`。由于我们使用了`nullptr`，分配器将根据默认的分配策略来进行内存分配。

需要注意的是，尽管`hint`参数提供了一个提示，但它并不保证会产生预期的结果。在实际应用中，我们需要根据具体的需求和性能考虑，合理使用`hint`参数。

总结一下，C++标准库中的 `allocate` 函数有一个重载版本，可以接受一个额外的参数 `hint`。这个参数用于提供一个内存分配的提示，但并不保证会被内存分配器有效利用。在大多数情况下，我们可以将 `hint` 参数设置为 `nullptr`，以使用默认的分配策略。

---
回到分配器
![[Pasted image 20230709182456.png]]
更高效的 allocator:
![[Pasted image 20230709182519.png]]
![[Pasted image 20230709182534.png]]
But G4.9 就用回了 new/delete 
![[Pasted image 20230709182617.png]]
那个链表组织的高效分配器 alloc, 变成了扩充分配器 `__poor_alloc<>`, 命名空间在 `__gnu_cxx`
![[Pasted image 20230709182658.png]]