
# LAB2 调试分析 Linux0.00 任务切换

# 实验目的
-   通过调试一个简单的多任务内核实例，使大家可以熟练的掌握调试系统内核的方法；

-   掌握Bochs虚拟机的调试技巧；

-   通过调试和记录，理解操作系统及应用程序在内存中是如何进行分配与管理的；

# 实验内容
通过调试一个简单的多任务内核实例，使大家可以熟练的掌握调试系统内核的方法。这个内核示例中包含两个特权级 `3` 的用户任务和一个系统调用中断过程。我们首先说明这个简单内核的基本结构和加载运行的基本原理，然后描述它是如何被加载进机器 `RAM` 内存中以及两个任务是如何进行切换运行的。



1.  当执行完 `system_interrupt` 函数，执行 `153` 行 `iret` 时，记录栈的变化情况。
    ![](./images/Pasted%20image%2020230517191122.png)
    此时内核栈栈顶正是 SS: ESP 指向的位置 0x 10:0 x0E4C，里面存放的返回地址 0x0F: 0x10EB 和用户栈栈顶 0x 17:0 x0BD8 。在执行 iret 之后：
    ![](./images/Pasted%20image%2020230517191333.png)
    程序确实回到了返回地址 0x0F: 0x10EB ，此时 esp 正是 0x0BD8.
2.  当进入和退出 `system_interrupt` 时，都发生了模式切换，请总结模式切换时，特权级是如何改变的？栈切换吗？如何进行切换的？
    在中断发生，进入 `system_interrupt` 时，处理器会去 IDT 里查中断向量对应的中断描述符比如 `system_interrupt` 是 `0x08:system_interrupt`, 然后会把 SS: ESP 指向的栈顶会自动切换到当前 TSS （从 TR 去寻找当前任务的 TSS）中保存的当前进程的的内核栈栈顶。在 32 位保护模式下，TSS 中的 ESP0 字段（TSS 中存储的内核栈指针）指向进程的内核栈（也称为系统栈），当进程执行从用户态切换到内核态的操作时，同时也会切换到该进程的内核栈。完成栈的切换.
    -   CPU 从 IDT 表中找到第 0x80 号，得到 0x80 号对应的中断/陷阱门。
    -   CPU 通过 GDT 表找到中断/异常处理程序的段基址
    -   检查 CPL 和 DPL，判断 CPU 运行的特权级是否需要改变。对于系统调用来说需要转到内核态。当然这里还有其它一些安全检查。
    -   转内核态需要做的事情包括从 TSS 中找到装载 ss 和 esp 寄存器的值，这些值代表新特权的运行栈。当然也要保存旧特权级运行栈使用的 ss 和 esp 的值，把它们暂时保存在新栈里，以便后面恢复的时候使用。
    -   保存 EFLAGS, CS 和 EIP 寄存器的值到栈中。
    -   装载上面得到段选择符和偏移量到CS和EIP寄存器，形成下面处理中断的入口地址
    特权级别是通过选择器（Selector）来实现的，这些选择器存储在处理器状态段（Processor State Segment, PSS）中。在进入`system_interrupt`模式时，CPU会使用内核态的选择器来更新代码段寄存器（Code Segment Register, CS）和堆栈段寄存器（Stack Segment Register, SS），从而将特权级别提升到内核态，以便执行中断处理程序。
3.  当时钟中断发生，进入到 `timer_interrupt` 程序，请详细记录从任务 `0` 切换到任务 `1` 的过程。
    ![](./images/Pasted%20image%2020230517195440.png)
    这是当前任务 0 的 TSS, 下一条指令要切换到 GDT 中这个还没有执行过的 TSS。
    s：
    果然我们当前的的 TSS 发生变化：
    ![](./images/Pasted%20image%2020230517195633.png)
    这边的寄存器也发生了变化：![](./images/Pasted%20image%2020230517195710.png)
4.  又过了 `10ms` ，从任务 1 切换回到任务 `0` ，整个流程是怎样的？ `TSS` 是如何变化的？各个寄存器的值是如何变化的？
   ![](./images/Pasted%20image%2020230517200025.png)
    ![](./images/Pasted%20image%2020230517200158.png)
    刚刚切换过来，可以看到 TSS 中的值被恢复到寄存器中，所以他们的值是一样的：
    ![](./images/Pasted%20image%2020230517200323.png)
5.  请详细总结任务切换的过程。
>任务切换的本质是 TR 指向的 TSS 从旧的 TSS 变到新的 TSS。也就是说，TR 里的选择子对应的 TSS 就是当前任务的 TSS。在切换过程中，所有寄存器状态被保存到旧 TSS 的对应字段中，而寄存器们会被更新为新 TSS 里的字段指定的值。而不同的任务除了拥有自己的 TSS，还拥有自己的 LDT，不同任务自己的地址空间的段描述符可以在自己的 LDT（局部描述符表）中，而不是在 GDT（全局描述符表，所有任务共享）中。任务切换时，LDTR 也会切换到 TSS 指定的 LDT 选择子。
