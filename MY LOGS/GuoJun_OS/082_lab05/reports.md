# LAB5 进程运行轨迹的跟踪与统计

## 实验目的：
1. 基于模板 `process.c` 编写多进程的样本程序，实现如下功能：
    - 所有子进程都并行运行，每个子进程的实际运行时间一般不超过 `30` 秒；
    - 父进程向标准输出打印所有子进程的 `id` ，并在所有子进程都退出后才退出；
2. 在 `Linux 0.11` 上实现进程运行轨迹的跟踪。基本任务是在内核中维护一个日志文件 `/var/process.log` ，把从操作系统启动到系统关机过程中所有进程的运行轨迹都记录在这一 `log` 文件中。

3. 在修改过的 `0.11` 上运行样本程序，通过分析 `log` 文件，统计该程序建立的所有进程的等待时间、完成时间（周转时间）和运行时间，然后计算平均等待时间，平均完成时间和吞吐量。可以自己编写统计程序，也可以使用 `python` 脚本程序 `stat_log.py` 进行统计。

4. 修改 `0.11` 进程调度的时间片，然后再运行同样的样本程序，统计同样的时间数据，和原有的情况对比，体会不同时间片带来的差异。

## 实验内容：
1. 基于模板 `process.c` 编写多进程的样本程序，实现如下功能：

    - 所有子进程都并行运行，每个子进程的实际运行时间一般不超过 `30` 秒；
    - 父进程向标准输出打印所有子进程的 `id` ，并在所有子进程都退出后才退出；
 ```C
 int main(int argc, char * argv[])
{
    pid_t proc[10];int i = 0;
    for (i=0 ; i < 10; i++)
    {
        proc[i]=fork();
        if(proc[i]==0)
        {
            cpuio_bound(10,i,10-i);
            return 0;
        }
        else if(proc[i]<0)
        {
            printf("Failed to fork%d\n",i+1);
            return -1;
        }
    }
    for (i = 0; i < 10; i++)
    {
        printf("Child PID:%d\n",proc[i]);
    }
    wait(1);
    return 0;
}
```
设置 10 个，CPU 和 IO 时间不同的进程来进行日志的记录
![](images/Pasted%20image%2020230623003209.png)
1. 在 `Linux 0.11` 上实现进程运行轨迹的跟踪。基本任务是在内核中维护一个日志文件 `/var/process.log` ，把从操作系统启动到系统关机过程中所有进程的运行轨迹都记录在这一 `log` 文件中。

 **日志文件的打开**：
![](images/Pasted%20image%2020230623035102.png)
**轨迹的追踪**：
例如fork. c:
创建：
![](images/Pasted%20image%2020230623035155.png)
就绪：
```C
set_tss_desc(gdt+(nr<<1)+FIRST_TSS_ENTRY,&(p->tss));
set_ldt_desc(gdt+(nr<<1)+FIRST_LDT_ENTRY,&(p->ldt));
 p->state = TASK_RUNNING;    /* do this last, just in case */
fprintk(3,"%ld\t%c\t%ld\n",p->pid,'J',jiffies);
```
主要是在对进程进行状态的改变时记录日志。
1. 在修改过的 `0.11` 上运行样本程序，通过分析 `log` 文件，统计该程序建立的所有进程的等待时间、完成时间（周转时间）和运行时间，然后计算平均等待时间，平均完成时间和吞吐量。可以自己编写统计程序，也可以使用 `python` 脚本程序 `stat_log.py` 进行统计。

不知道为什么，日志会记录重复的 J：
![](images/Pasted%20image%2020230623035525.png)
这导致无法通过 python 脚本的统计
1. 修改 `0.11` 进程调度的时间片，然后再运行同样的样本程序，统计同样的时间数据，和原有的情况对比，体会不同时间片带来的差异。

时间片的初始值是进程 0 的 priority，是在 `linux-0.11/include/linux/sched.h` 的宏 `INIT_TASK` 中定义的，如下：我们只需要修改宏中的第三个值即可，该值即时间片的初始值。
```c
#define INIT_TASK \
    { 0,15,15,
// 上述三个值分别对应 state、counter 和 priority;
```
更改 `priority` 即可更改时间片。


## 问题回答
完成实验后，在实验报告中回答如下问题：

1. 结合自己的体会，谈谈从程序设计者的角度看，单进程编程和多进程编程最大的区别是什么？
    单进程是顺序执行的，多进程不同进程间执行顺序是不确定的，这会带来同步的复杂性，但多进程编程更适合处理多个任务，它可以将其划分为多个进程，每个进程执行一个任务。这种方式可以充分利用多核 CPU 的性能，提高应用程序的并发性能。
2. 你是如何修改时间片的？仅针对样本程序建立的进程，在修改时间片前后， `log` 文件的统计结果（不包括 Graphic）都是什么样？结合你的修改分析一下为什么会这样变化，或者为什么没变化？

将时间片设为 5，10，15，20，25，50，100 经观察log 文件可以发现：
1）在一定的范围内，平均等待时间，平均完成时间的变化随着时间片的增大而减小。因为在时间片小的情况下, 调度切换耗费大，平均等待时间增加。
2）超过一定的范围后，参数不再有明显的变化，这是因为在这种情况下，RR轮转调度就变成了FCFS先来先服务了。



