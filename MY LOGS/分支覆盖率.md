```sh
sudo apt install lcov
sudo apt install openjdk-8-jdk

//设置java8为默认版本
sudo update-alternatives --config java
sudo update-alternatives --config javac

```

`vi /etc/lcovrc` 修改lcovrc
```
lcov_branch_coverage = 1  // 去掉注释，值改为1

genhtml_branch_coverage = 1 // 去掉注释，值改为1
```



```python
#!/usr/bin/env python3
# coding=utf-8
import os
import subprocess
import json
import stat
import sys
FLAGS = os.O_WRONLY | os.O_CREAT | os.O_EXCL
MODES = stat.S_IWUSR | stat.S_IRUSR
def get_source_file_list(path):
    """
    获取path路径下的 .c 和 .cpp 源文件路径列表
    """
    file_path_list = []
    for root, dirs, files in os.walk(path):
        for file_name in files:
            _, suffix = os.path.splitext(file_name)
            if suffix in [".c", ".cpp"]:
                file_path_list.append(os.path.join(root, file_name))
    return file_path_list
def rewrite_source_file(source_path_list: list):
    """
    给源文件中非关键分支语句的行添加 //LCOV_EXCL_BR_LINE 注释
    """
    keys = ["if", "while", "switch", "case", "try", "catch"]
    if not source_path_list:
        print("没有发现任何源文件")
        return
    print("[********** 开始修改源文件 **********]")
    for path in source_path_list:
        if not os.path.exists(path) or "test" in path:
            continue
        with open(path, "r", encoding="utf-8", errors="ignore") as read_fp:
            code_lines = read_fp.readlines()
        source_dir, suffix_name = os.path.splitext(path)
        backup_path = f"{source_dir}_bk{suffix_name}"
        if os.path.exists(backup_path):
            os.remove(backup_path)
        with os.fdopen(os.open(backup_path, FLAGS, MODES), 'w') as write_fp:
            for line in code_lines:
                sign_number = 0
                for key in keys:
                    sign_number += 1
                    if key in line and line.strip().startswith(key):
                        write_fp.write(line)
                        break
                    elif " //LCOV_EXCL_BR_LINE" not in line and not line.strip().endswith("\\") and sign_number == len(keys):
                        write_fp.write(f"{line.rstrip()} //LCOV_EXCL_BR_LINE\n")
                        break
                    elif sign_number == len(keys):
                        write_fp.write(line)
                        break
        os.remove(path)
        subprocess.run(["mv", backup_path, path])
        print(f"已处理文件: {path}")
    print("[********** 所有文件处理完成 **********]")
if __name__ == '__main__':
    if len(sys.argv) < 2:
        print("用法: python3 add_lcov.py <目录1> [目录2] ...")
        sys.exit(1)
    for directory in sys.argv[1:]:
        if os.path.exists(directory):
            print(f"\n>> 正在处理目录: {directory}")
            source_file_path = get_source_file_list(directory)
            print(f"  找到 {len(source_file_path)} 个源文件")
            rewrite_source_file(source_file_path)
        else:
            print(f"目录不存在: {directory}")
```
执行以上python脚本，执行时指定代码目录，脚本会在源码中插入注释屏蔽冗余分支，执行示例：
`python lcov_exclude_rewriter.py /home/z30061262/workspace/panda`


```sh
cd runtime_core/static_core/
mkdir build
cd build
cmake ../ -GNinja -DCMAKE_BUILD_TYPE=Debug -DENABLE_UNIT_TESTS_FULL_COVERAGE=true
ninja -k1 panda_bins ark_disasm es2panda arkquick declgen_ets2ts
```

runner.sh
```
# runtime_core目录
# 指定build目录，运行所有相关的runner测试套,例如
static_core/tests/tests-u-runner/runner.sh --parser  --build-dir static_core/build --interpreter-type=cpp --show-progress --processes 31 --work-dir static_core/coverage/parser --es2panda-timeout=120 --compare-files-iterations=2
# 生成runner的覆盖率报告
static_core/build目录
lcov -c -d . -o result.info
lcov -remove result.info '*/tests/*' '*/test/*' '*.h' '*/*.h' '*/napi/*' '*/Napi/*' '*/NAPI/*' '*/moduletest/*' '*/systemtest/*' '*/third_party/*' '/usr/*' -o runner.info
genhtml -o coverage runner.info --ignore-errors source --quiet --rc lcov_branch_coverage=1
zip -r coverage.zip coverage
# coverage.zip是最后的覆盖率报告
```

unittest测试：
static_core/build目录
ninja -k 100000 coverage_full
合并unittest和runner测试报告



**文件格式化：1、clang-tidy code-check**  
1、复制脚本 [code_format.sh](https://gitee.com/ziziziiziziz/scripts/blob/master/code_format.sh) 到自己的 arkcompiler目录下  
2、进行如下修改  
![输入图片说明](https://foruda.gitee.com/images/1740109694345361380/6afaa148_7438463.png "屏幕截图")  
3、执行 bash code_format.sh, 即可对自己的修改进行校验  
![输入图片说明](https://foruda.gitee.com/images/1740109889353444392/ec843eeb_7438463.png "屏幕截图")  
![](https://foruda.gitee.com/images/1740109926299760939/4b98da40_7438463.png "屏幕截图")

将红色错误改为绿色，以及所有告警错误均需要修改，修改直至控制台不再输出错误

**文件格式化：2、code_style_tool**  
运行如下命令：  
bash runtime_core/static_core/scripts/code_style/run_code_style_tools.sh <文件路径>  
即可对修改的文件进行校验，修改直至控制台不再输出红绿色错误提示，

**文件格式化：3、static-check**  
通过在PR中评论 static-check 来进行代码风格检查