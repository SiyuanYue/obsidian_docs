所有的处理器都开始执行 `os->run()`，操作系统正式启动，而启动代码就成为了当前处理器上的第一个线程——这个线程是这个处理器上的 “idle” 线程：当系统中没有线程可以被调度的时候，我们的处理器也必须执行点什么，直到下一次中断到来，因此它可以是一个死循环.
-  因为每个处理器都会被中断，这让 `os->trap()` 变成了被并行执行的代码。因此，如果里面有任何共享变量，你需要用自旋锁保护好 (并且要小心死锁，并小心地管理中断标志位)，消灭数据竞争.

*开启多处理器后 （`smp>=1`）：*
-   `data race` ：保证被中断的线程返回之前不会被调度到其他的处理器
-  大家可以考虑一下，如果在关闭中断的时候 yield () 会发生什么。考虑清楚这个问题，请把计算机系统的执行想象成状态机；计算机的状态完全是由寄存器和内存的数值决定的，而控制中断开关的是 EFLAGS 寄存器中的 IF。

**P 、V 信号量的实现正确性。**           <--- 关于 yield
类似于M2的BUG出现了，可能是**调度有bug，循环卡死**或者context save导致的。
简单的test通过，但基本的PV操作就寄了，而且有时候加个printf/putch能正常调度，有时候不加就堵住了调度，很奇怪！！！！！

**破案！！！！**
实锤是`task_t` 中的`ctx`是`Context *`,在保存的时侯用了：
```C
memcpy(_current->context, context, sizeof(Context));
```
但不知怎滴，有点小问题,可能是`sizeof(Context))`或者`klib`中的`memcpy()`实现的有冲突？context save错误导致**BUG**！！！！！
完成基本sem_wait_base(P)和sem_signal_base(V),能跑通dev_init()，启动dev模块，多处理器还存在问题
剩余：
1. 睡眠的信号量（等待队列······）
2. 多处理器

![[Pasted image 20230202183421.png]]

![[Pasted image 20230222164336.png]]
第二个核切换线程时直接 crash 掉了
给切换打上 cpu 号明确问题所在
想想多核下线程切换和初始线程的模型到底啥样。（*idle 是不是可以不加入alltasks*）
![[Pasted image 20230222223525.png]]
![[Pasted image 20230222223800.png]]
应该也不能是别的 cpu 核正在运行的线程!！
![[Pasted image 20230222224041.png]]

`yield ()` 前增加 `if(ienabled())`
![[Pasted image 20230222233420.png]]
![[Pasted image 20230222233508.png]]
多核 OK 啦！