# 1.中断和异常处理概述
## 什么是中断和异常
中断和异常是指示系统、处理器或当前正在执行的程序或任务存在某种需要处理器关注的情况的事件。它们通常会强制将执行从当前正在运行的程序或任务转移至一个特殊的软件例程或任务 (切换到特殊的执行流（内核态）)，称为中断处理程序或异常处理程序。处理器对中断或异常的响应所采取的动作被称为服务或处理中断或异常。
在程序执行过程中，中断随机发生，响应于来自硬件的信号。系统硬件使用中断来处理处理器外部的事件，如请求服务外围设备。软件还可以通过执行`int n` 指令生成中断。当处理器在执行指令时检测到错误条件（例如除以零）时，就会发生异常。处理器检测各种错误条件，包括保护违规、页面故障和内部机器故障。pentium 4、intel xeon、p6 系列和 pentium 处理器的机器检查架构也允许在检测到内部硬件错误和总线错误时生成机器检查异常。
## 处理器如何处理中断与异常
当接收到中断或检测到异常时，当前正在运行的过程或任务将被挂起，而处理器执行中断处理程序或异常处理程序。当处理程序执行完成后，处理器继续执行已中断的过程或任务。除非无法从异常中恢复或中断导致当前正在运行的程序被终止，否则中断的过程或任务的恢复不会丢失程序连续性。
## 思考题 ：实模式和保护模式下，中断向量表一样吗？
在实模式和保护模式下，中断向量表是不同的。
在*实模式*下，中断向量表是由一组4字节指针数组组成，这些指针包含了*每个中断服务例程的地址*。这些地址采用实地址方式编码，并存储在物理内存的0x0000到0xffff之间的固定位置处。
而在保护模式下，中断向量表也是由一组指针数组组成，但指针中存储的*不是实地址*，而是线性地址，这些指针所指向的*中断服务例程可以分别位于系统的各个段中*。中断向量表默认存储在内存地址 0x00 00:0 x0000 处（即物理地址 0x00000），`IDTR` 寄存器来记录中断描述符表 (`IDT`) 的起始地址和限长。
因此，在不同的运行模式下，中断向量表的结构和存储方式都有所不同
# 2. 有关中断和异常了解性的内容
## 中断和异常向量
为了帮助处理异常和中断，每个体系结构定义的异常以及每个需要处理器进行特殊处理的中断条件都被分配了一个唯一的标识号，称为向量号。处理器使用分配给异常或中断的向量号作为索引进入中断描述符表 (`IDT`)。
该表提供了异常或中断处理程序的入口点。向量号的允许范围为 0 到 255。值在 0 到 31 之间的向量号由 intel 64 和 ia-32 架构保留用于体系结构定义的异常和中断。这个范围内不是所有的向量号都有目前已定义的功能。这个范围内未分配的向量号被保留。不要使用已经保留的向量号。
范围在 32 到 255 的向量号被指定为用户定义的中断，并且没有被 intel 64 和 ia-32 架构保留。这些中断通常分配给外部 I/O 设备，以使这些设备能够通过其中一种外部硬件中断机制向处理器发送中断。
## 中断源：
### External (hardware generated) interrupts. 外部硬件中断
外部中断是通过处理器上的*引脚* 或*本地 apic* 接收的。 Pentium 4, Intel Xeon, P6 family, and Pentium 处理器的主要中断引脚是 `LINT[1: 0]` 引脚，它们连接到本地 APIC（请参见第 11 章“高级可编程中断控制器（apic）”）。当启用本地 APIC 时，`LINT[1: 0]` 引脚可以通过 apic 的本地向量表（lvt）进行编程，与处理器的任何异常或中断向量相关联。
>通常， `[1:0]` 表示该信号是一个包含两个引脚的总线，分别命名为 `lint1` 和 `lint0`。比如在某些数字系统中，pci 规范定义 lintx 作为 pci（peripheral component interconnect）插槽中高电平触发信号之一，每个插槽都有 4 个不同的指定高电平触发信号线，分别称为 lint0，lint1，lint2 和 lint3。

当本地 apic 被全局/硬件禁用时，这些引脚分别配置为 `INTR` 和 `NMI` 引脚。设置 `INTR` 引脚表示向处理器发出外部中断的信号。处理器从系统总线中读取由*外部中断控制器*（例如 8259a，参见第 6.2 节“异常和中断向量”）提供的中断向量号。设置 `NMI` 引脚表示*不可屏蔽中断*已经发生，它被分配给*中断向量 2*。
处理器的本地 APIC 通常连接到基于系统的 I/O APIC。在这里，通过系统总线（Pentium 4、Intel Core Duo、Intel Core2、Intel Atom 和 Intel Xeon 处理器）或 APIC 串行总线（P6 家族和 Pentium 处理器），可以将接收到的外部中断引导到本地 APIC。I/O APIC 确定中断的向量号，并将此号码发送到本地 APIC。当系统包含多个处理器时，处理器也可以通过系统总线（Pentium 4、Intel Core Duo、Intel Core 2、Intel Atom 和 Intel Xeon 处理器）或 APIC 串行总线（P6 家族和 Pentium 处理器）彼此发送中断。 Intel 486 处理器和早期不含芯片上本地 APIC 的 Pentium 处理器上不提供 `LINT [1：0]`引脚。这些处理器有专用的 NMI 和 INTR 引脚。对于这些处理器，外部中断通常由基于系统的中断控制器（8259A）生成，并通过 INTR 引脚发出中断信号。请注意，处理器上的其他几个引脚也可能导致处理器中断发生。但是，这些中断不由本章中描述的中断和异常机制处理。这些引脚包括 RESET # ，FLUSH＃，STPCLK＃，SMI＃，R / S＃和 INIT＃引脚。它们是否包含在特定处理器上取决于实现。引脚功能在各个处理器的数据手册中有描述。SMI＃引脚在第 32 章“系统管理模式”中有描述。
### Maskable Hardware Interrupts 可屏蔽硬件中断
通过 INTR 引脚或本地 APIC 传递给处理器的任何外部中断称为可屏蔽硬件中断（与设置 NMI 引脚的不可屏蔽中断区分）。可以通过 INTR 引脚传递的可屏蔽硬件中断包括从 0 到 255 的所有 IA-32 架构定义的中断向量；可以通过本地 APIC 传递的包括 16 到 255 的中断向量。*EFLAGS 寄存器中的 IF 标志允许将所有可屏蔽硬件中断作为一组被屏蔽*（请参阅 6.8.1 节“屏蔽可屏蔽硬件中断”）。请注意，当中断 0 到 15 通过本地 APIC 传递时，APIC 会指示接收到非法向量。
###  Software-generated interrupts. 软件产生的中断
`INT n`指令允许通过提供一个中断向量号作为操作数，从软件内部生成中断。例如，INT 35指令强制隐式调用中断处理程序来处理中断35。在这个指令中可以使用0到255之间的任何中断向量作为参数。但是，如果使用处理器预定义的NMI向量，处理器的响应将不同于通过正常方式生成的NMI中断。如果在此指令中使用向量号2（NMI向量），则会调用NMI中断处理程序，但不会激活处理器的NMI处理硬件。*使用INT n指令在软件中生成的中断不能由EFLAGS寄存器中的IF标志屏蔽。*
## 异常源
处理器从三个来源接收异常:
###  处理器检测到的程序错误异常。
当处理器在应用程序、操作系统或执行程序的执行过程中检测到程序错误时，会生成一个或多个异常。Intel 64 和 IA-32 体系结构为每个可由处理器检测到的异常定义了一个向量号。异常被分类为故障、陷阱和终止（参见第 6.5 节“异常分类”）
### 软件生成的异常
INTO、INT1、INT3 和 BOUND 指令允许在软件中生成异常。这些指令允许在指令流中的某些点执行异常条件检查。例如，INT3 会引发断点异常。*INT n*指令可用于在软件中模拟异常；但存在限制。如果 INT n 提供一个由体系结构定义的异常向量，处理器会生成一个中断到正确的向量（以访问异常处理程序），但不会将错误代码推送到堆栈上。即使相关的硬件生成的异常通常产生一个错误代码，这也是真实的。在处理异常时，异常处理程序仍将尝试从堆栈中弹出一个错误代码。由于没有推送错误码，处理程序将从堆栈中弹出并丢弃 EIP，以代替缺失的错误码。这会将返回发送到错误的位置。
>例如系统调用在 x86 架构下的 *INT 0x80* 指令；也可以是 syscall 指令
### 机器检查异常。
P6 家族和奔腾处理器提供内部和外部的机器检查机制来检查内部芯片硬件和总线事务的操作。这些机制是实现相关的。当检测到机器检查错误时，处理器会发出机器检查异常（向量 18），并返回一个错误代码。

## 异常的分类：故障、陷阱和中止
根据异常*报告的方式*以及*导致异常的指令是否可以在不丢失程序或任务连续性的情况下重新启动*，异常被分类为故障，陷阱或中止。

* 故障 - 故障是一种*通常可以纠正的异常*，一旦纠正，程序可以重新启动，而不会丢失连续性。当上报故障时，处理器将机器状态恢复到执行故障指令之前的状态。故障处理程序的返回地址（CS 和 EIP 寄存器的保存内容）指向故障指令，而不是指向故障指令后面的指令。
* 陷阱 - 陷阱是在*陷阱指令执行后立即报告的异常*。陷阱允许在没有丢失程序连续性的情况下继续执行程序或任务。*陷阱处理程序的返回地址指向在陷阱指令后要执行的指令*。
*  中止 - 中止是一种异常，它不总是报告导致异常的指令的精确位置，并且不允许重新启动导致异常的程序或任务。中止用于报告严重错误，例如硬件错误和系统表中不一致或非法的值。
## 程序或任务的重新执行
为了允许在处理异常或中断后重新启动程序或任务，所有异常（除了中止）保证在指令边界报告异常。所有中断保证在指令边界进行。对于故障类异常，返回指令指针（在处理器产生异常时保存）指向出现故障的指令。因此，在处理故障后重新启动程序或任务时，会重新启动（重新执行）故障指令。重新启动故障指令通常用于处理访问操作数被阻止时生成的异常。这种类型故障的最常见示例是当程序或任务引用位于内存中不存在的页面上的操作数时发生的页面故障异常（#PF）。当页面故障异常发生时，异常处理程序可以将页面加载到内存中，并通过重新启动故障指令来恢复程序或任务的执行。为确保重新启动能够透明地处理当前正在执行的程序或任务，处理器保存必要的寄存器和堆栈指针，以允许重新启动到执行故障指令之前的状态。对于陷阱类异常，返回指令指针指向触发指令后面的指令。如果在转移执行的指令中检测到陷阱，则返回指令指针反映转移。例如，在执行JMP指令时检测到陷阱，返回指令指针指向JMP指令的目标，而不是JMP指令之后的下一个地址。所有陷阱异常都允许程序或任务在没有连续性丢失的情况下重新启动。例如，溢出异常是一种陷阱异常。在这里，返回指令指针指向测试EFLAGS.OF（溢出）标志的INTO指令后面的指令。此异常的陷阱处理程序解决溢出条件。从陷阱处理程序返回后，程序或任务的执行将在INTO指令后面的指令继续。

异常类中的 abort 异常不支持程序或任务的可靠重启。Abort 处理程序旨在在发生 abort 异常时收集处理器状态的诊断信息，然后尽可能优雅地关闭应用程序和系统。中断严格支持中断程序和任务的重启，而不会丢失连续性。保存中断返回指令指针的地址指向处理器中断发生时要执行的下一条指令的指令边界位置。如果刚刚执行的指令有重复前缀，则中断在当前迭代结尾处发生，并将寄存器设置为执行下一次迭代。P6 系列处理器的规范执行指令的能力不影响处理器接受中断。中断在指令执行的退役阶段中定位到的指令边界处发生，因此它们始终在“有序”的指令流中进行。请参见《Intel64 和 IA-32 体系结构软件开发人员手册》第 1 卷中的第 2 章“Intel 64 和 IA-32 体系结构” ，了解 P6 系列处理器的微体系结构及其对乱序指令执行的支持。请注意，Pentium 处理器和早期 IA-32 处理器也执行不同数量的预取和初步解码。对于这些处理器，除非实际执行指令才会发出异常和中断信号。在给定的代码样本中，无论在哪种 IA-32 处理器系列上执行代码，异常信号的发出都是统一的（除非定义了新的异常或新的操作码）。

## ENABLING AND DISABLING INTERRUPTS 开启和禁止中断
处理器会根据处理器本身的状态以及 eflags 寄存器中 if 和 rf 标志位的状态，禁止产生某些中断。
## 屏蔽可屏蔽的硬件中断 (Masking Maskable Hardware Interrupts)
IF 标志位可以禁用在处理器的 INTR 引脚或本地 APIC 上接收到的可屏蔽硬件中断的服务（请参见第 6.3.2 节“可屏蔽硬件中断”）。当 IF 标志位被清除时，处理器会阻止通过 INTR 引脚或本地 APIC 传递的中断产生内部中断请求；当 IF 标志位被设置时，通过 INTR 引脚或本地 APIC 传递的中断会像正常的外部中断一样被处理。
IF 标志位不影响传递到 NMI 引脚或通过本地 APIC 传送的交付模式 NMI 消息的不可屏蔽中断（NMI），也不影响处理器生成的异常。与 EFLAGS 寄存器中的其他标志位一样，在响应硬件复位时，处理器会清除 IF 标志位。
可屏蔽硬件中断包括保留的中断和异常向量 0 至 32 号，这一事实可能会引起混淆。从架构上讲，当 IF 标志位被设置时，从 0 到 32 号向量的任何中断都可以通过 INTR 引脚传递到处理器，16 到 32 号向量的任何中断都可以通过本地 APIC 传递。然后，处理器将生成一个中断并调用由向量号指向的中断或异常处理程序。例如，可以通过 INTR 引脚（借助于向量 14）调用页面故障处理程序；但是，这不是真正的页面故障异常，而是一个中断。与 INT n 指令一样（请参见第 6.4.2 节“软件生成的异常”），当通过 INTR 引脚生成中断到异常向量时，处理器不会将错误代码推送到堆栈上，因此异常处理程序可能无法正确操作。
IF标志位可以通过STI指令（设置中断允许标志）和CLI指令（清除中断允许标志）分别设置或清除。这些指令只能在CPL等于或小于IOPL时执行。如果在CPL大于IOPL时执行它们，将产生通用保护异常（#GP）。如果IF = 0，则在执行STI后的指令边界上，可屏蔽硬件中断仍将被禁止。2 禁止会在传递另一个事件（例如异常）或执行下一条指令之后结束。IF标志位也受以下操作的影响：·PUSHF指令将所有标志存储在堆栈上，其中可以对它们进行检查和修改。POPF指令可用于将修改后的标志加载回EFLAGS寄存器。·任务切换和POPF和IRET指令加载EFLAGS寄存器；因此，它们可用于修改IF标志位的设置。·当通过中断门处理中断时，IF标志自动清除，从而禁用可屏蔽硬件中断。（如果通过陷阱门处理中断，则不清除IF标志。）有关这些指令在IF标志上允许执行的详细操作，请参见 <<intel64和IA-32体系结构软件开发人员手册》第2A卷第3章“指令集参考，A-L”和第2B卷第4章“指令集参考，M-U”的CLI、 STI、PUSHF、POPF和IRET指令描述。
### 掩码指令断点（Masking Instruction Breakpoints）
在 eflags 寄存器中，RF （恢复）标志控制处理器对指令断点条件的响应（请参阅“eflags 寄存器中的系统标志和字段”第 2.3 节中 rf 标志的描述）。当设置时，它会防止指令断点生成调试异常（#db）；当清除时，指令断点将生成调试异常。rf 标志的主要功能是防止处理器在指令断点上进入调试异常循环。有关使用此标志的更多信息，请参阅第 18.3.1.1 节“指令断点异常条件”。
如第 6.8.3 部分所述，执行 mov 或 pop 指令来加载 ss 寄存器将抑制下一条指令上的任何指令断点（就像 eflags.rf 为 1 一样）。
在 eflags 寄存器中，rf （恢复）标志控制处理器对指令断点条件的响应（请参阅“eflags 寄存器中的系统标志和字段”第 2.3 节中 rf 标志的描述）。当设置时，它会防止指令断点生成调试异常（#db）；当清除时，指令断点将生成调试异常。rf 标志的主要功能是防止处理器在指令断点上进入调试异常循环。有关使用此标志的更多信息，请参阅第 18.3.1.1 节“指令断点异常条件”。
执行 mov 或 pop 指令来加载 ss 寄存器将抑制下一条指令上的任何指令断点（就像 eflags. rf 为 1 一样）。
### 在切换堆栈时屏蔽异常和中断
为了切换到不同的堆栈段，软件通常使用一对指令，例如：
```
MOV SS，AX
MOV ESP，StackTop
```
（软件也可以使用 POP 指令来加载 SS 和 ESP）。如果在新的 SS 段描述符已被加载但 ESP 寄存器尚未被加载时发生中断或异常，则这些逻辑地址的两个部分在中断或异常处理程序的持续时间内与堆栈空间不一致（假设中断或异常的传递本身不会加载新的堆栈指针）。为了解决这种情况，处理器在执行 MOV 到 SS 指令或 POP 到 SS 指令之后阻止某些事件被传送。以下内容提供详细信息：
• 下一条指令上的任何指令断点都会被禁止（就像 EFLAGS. RF 为 1 一样）。
• 对于 MOV 到 SS 指令或 POP 到 SS 指令的数据断点将被抑制，直到下一个指令后的指令边界。
• 由于 EFLAGS. TF 为 1，将在 MOV 到 SS 指令或 POP 到 SS 指令之后传送的任何单步陷阱都将被抑制。
• 抑制和禁止在传送异常或执行下一条指令后结束。
• 如果一系列连续的指令每个加载 SS 寄存器（使用 MOV 或 POP），只有第一个指令被保证以这种方式抑制或禁止事件。 Intel 建议软件使用 LSS 指令一起加载 SS 寄存器和 ESP。早先发现的问题不适用于 LSS，而 LSS 指令不会像上面详细说明的那样禁止事件。

## 异常的优先级
如果在一条指令执行之间存在多个待处理的事件，处理器将按照可预测的顺序进行服务。
![](./images/Pasted%20image%2020230423211148.png)

![](./images/Pasted%20image%2020230423211210.png)

# 3 中断描述符表（IDT）
中断描述符表（IDT）将每个异常或中断向量与用于服务相关异常或中断的过程或任务的门描述符关联起来。与 GDT 和 LDT 不同，IDT 的第一个条目可以包含描述符。在保护模式下，IDT 是 8 字节描述符（数组）。为了形成 IDT 索引，处理器将异常或中断向量乘以 8（门描述符的字节数）。由于仅有 256 个中断或异常向量，IDT 不需要包含超过 256 个描述符。它可以包含少于 256 个描述符，因为仅需要为可能发生的中断和异常向量配置描述符。IDT 中的所有空描述符槽应将描述符设置的存在标志设置为 0。
IDT 的基地址应该对齐到 8 字节边界，以最大化缓存线填充的性能。限制值以字节为单位表示，并添加到基地址上以获得最后一个有效字节的地址。限制值为 0 将导致恰好 1 个有效字节。由于 IDT 条目始终为 8 字节长，因此限制应始终比 8 的整数倍小 1（即 8N-1）。
IDT 可以位于线性地址空间的任何位置。如图 6-1 所示，处理器使用 IDTR 寄存器定位 IDT。此寄存器包含 IDT 的 32 位基地址和 16 位限制。
LIDT（加载 IDT 寄存器）和 SIDT（存储 IDT 寄存器）指令分别加载和存储 IDTR 寄存器的内容。LIDT 指令使用存储器操作数中保存的基地址和限制将 IDTR 寄存器加载。只有 CPL 为 0 时才能执行此指令。当创建 IDT 时，操作系统的初始化代码通常会使用它。操作系统还可以使用它从一个 IDT 切换到另一个 IDT。SIDT 指令将 IDTR 中存储的基址和限制值复制到内存中。该指令可在任何特权级别下执行。
> 由于中断只会被传递给处理器内核一次，因此配置不正确的中断描述表（idt）可能会导致不完整的中断处理和/或阻止中断传递。ia-32 架构规则需要遵循设置 idtr 基址/限制/访问字段和门描述符中每个字段的规则。对于 intel 64 架构也同样适用。这包括隐式引用 gdt 或 ldt 中的目标代码段以及对堆栈的访问。

# 4. 中断描述符（IDT DESCRIPTORS）
idt 可能包含以下三种类型的门描述符：
*  任务门描述符
*  中断门描述符
*  陷阱门描述符

在 idt 中使用的任务门的格式与在 gdt 或 ldt 中使用的任务门相同 (参见第 8.2.5 节《任务门描述符》)。任务门包含用于异常处理或中断处理任务的 tss 的段选择器。中断门和陷阱门与调用门非常相似 (参见第 5.8.3 节《调用门》)。它们包含一个远指针 (段选择器和偏移量)，处理器使用该指针将程序执行转移到异常处理程序或中断处理程序代码段中的处理程序。这些门的不同之处在于处理器处理 eflags 寄存器中的 if 标志的方式 (参见第 6.12.1.3 节“异常或中断处理程序使用的标志用法”)。
![](./images/Pasted%20image%2020230423211844.png)

# 5. 中断与异常处理
## 中断过程调用的流程是怎样的
处理器处理对异常和中断处理程序的调用方式类似于处理对过程或任务的 call 指令的调用。在响应异常或中断时，处理器将*异常或中断向量*用作 IDT 中描述符的索引。如果索引指向中断门或陷阱门，则处理器以类似于调用门（参见第 5.8.2 节“门描述符”到第 5.8.6 节“从被调用过程返回”）的方式调用异常或中断处理程序。如果索引指向任务门，则处理器执行任务切换到异常或中断处理程序任务，方式类似于调用任务门（参见第 8.3 节“任务切换”）。
### 中断或异常处理程序
中断门或陷阱门引用一个异常或中断处理例程，这个例程运行于当前执行任务的上下文中，门描述符中的偏移字段指向异常或中断处理例程的入口。
![](./images/Pasted%20image%2020230423214542.png)

##   如何判断中断处理过程与被中断任务的优先级？
按照中断向量号的优先级顺序处理，即先处理中断向量号低的中断，然后再处理中断向量号高的中断。
##   不同优先级上，处理方式一样吗？
 不一样，如下。
##  如果发生堆栈切换，处理器会做哪些操作？
当处理器执行对异常或中断处理程序的调用时： 
•如果处理程序是比被中断进程的特权极高，则会发生*堆栈切换*。当堆栈切换发生时：
	a. 从当前执行任务的 TSS 获取要由处理程序使用的堆栈的段选择子和堆栈指针。在这个*新的堆栈*上，处理器将中断的过程的*堆栈段选择子和堆栈指针推入堆栈*中。然后处理器将*EFLAGS、CS 和 EIP 寄存器的当前状态保存到新的堆栈中*（见图 6-4）。
	 b. 如果一个异常导致错误码被保存，它会在 EIP 值之后被推到新的堆栈中。
## 如果没发生堆栈切换，处理器会做哪些操作？
如果处理程序将在与中断的过程相同的特权级别下执行： 
 a. 处理器将 EFLAGS、CS 和 EIP 寄存器的当前状态保存在*当前堆栈*中（见图 6-4）。 
 b. 如果异常导致错误码被保存，它会在 EIP 值之后被推到当前堆栈中。
##  中断处理过程后，如何返回，处理器做了哪些操作？
 要从异常或中断处理程序返回，处理程序必须使用 IRET（或 IRETD）指令。
 IRET 指令类似于 RET 指令，但它将保存的标志位恢复到 EFLAGS 寄存器中。只有在 CPL 为 0 时，EFLAGS 寄存器的 IOPL 字段才会被恢复。如果 CPL 小于或等于 IOPL，则只有 IF 标志位会被修改。
 如果在调用处理程序时发生了堆栈切换，则 IRET 指令在返回时切换回被中断过程的堆栈。
##   异常和中断处理过程的保护
异常处理和中断处理程序的特权级保护与通过调用门调用时用于普通过程调用的类似（参见第 5.8.4 节，“通过调用门访问代码段”）。当调用到较低特权级（CPL 数值更大的特权级）的代码段中的异常或中断处理程序时，处理器不允许执行转移。违反此规则的尝试会导致通用保护异常（＃GP）。
异常和中断处理程序的保护机制有以下不同之处：
•由于中断和异常向量没有请求特权级（RPL），因此在隐式调用异常和中断处理程序时不检查 RPL。
•仅当使用 INT n，INT3 或 INTO 指令生成异常或中断时，处理器才检查中断或陷阱门的 DPL。在这种情况下，CPL 必须小于或等于门的 DPL。此限制可以防止运行在特权级 3 的应用程序或过程使用软件中断来访问关键异常处理程序（例如页面故障处理程序），前提是这些处理程序放置在更高特权级的代码段中（数值较低的特权级）。对于硬件生成的中断和处理器检测到的异常，处理器会忽略中断和陷阱门的 DPL。由于异常和中断通常不会在可预测的时间发生，因此这些特权规则有效地对异常和中断处理过程可以运行的特权级施加了限制。可以使用以下任一技术来避免特权级违规。
•异常或中断处理程序可以放置在符合规范的代码段中。该技术可用于只需要访问堆栈上可用数据（例如，除法错误异常）的处理程序。如果处理程序需要来自数据段的数据，则需要从特权级 3 可访问该数据段，这将使其不受保护。
•处理程序可以放置在特权级为0的非符合规范的代码段中。该处理程序将始终运行，而不管被中断的程序或任务正在运行的CPL是什么。
##  异常和中断处理过程的标志使用方式
当通过中断门或陷阱门访问异常或中断处理例程时，在将 EFLAGS 寄存器的内容保存进栈 后，处理器会清 EFLAGS 寄存器的 TF 位。（当调用异常和中断处理例程时，处理器在将 EFLAGS 寄存器的内容保存进栈后，还会清 VM，RF，和 NT 位。）清 TF 位则可以禁止指令跟踪，以 使中断响应不受影响。后继的 IRET 指令则使用保存在栈中的 EFLAGS 寄存器中的值，恢复 TF（和 VM，RF，及 NT）位。 中断门和陷阱门的唯一区别在于处理器处理 EFLAGS 寄存器的 IF 位的方式。当通过中断门 访问异常或中断处理例程时，处理器清除 IF 位，以阻止另外的中断干扰当前的中断处理例 程。后继的 IRET 指令用存储在栈中的 EFLAGS 的内容恢复 IF 的值。而通过陷阱门调用处理 例程时，IF 位不受影响。
## 中断门与陷阱门的唯一区别是什么？
Intel处理器中断门和陷阱门的唯一区别是，当发生中断时，中断门会禁用外部中断，而陷阱门不会禁用外部中断。换句话说，中断门提供了一个可重入的中断服务例程，它可以被中断中断，而陷阱门不能在其执行期间被中断。
