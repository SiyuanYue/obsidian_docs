## 3.1 概览
IA-32体系结构的内存管理设施分为两部分：分段和分页。分段提供了一种机制，可以隔离单个代码、数据和堆栈模块，以便多个程序（或任务）可以在同一处理器上运行，而不会相互干扰。分页提供了一种机制，用于实现传统的按需分页虚拟内存系统，其中程序执行环境的部分被映射到物理内存中，只有在需要时才加载。分页还可以用于在多个任务之间提供隔离。在保护模式下运行时，必须使用某种形式的分段。没有模式位可以禁用分段。但是，使用分页是可选的。
这两种机制（分段和分页）可以配置为支持简单的单程序（或单任务）系统、多任务系统或使用共享内存的多处理器系统。

![](./images/Pasted%20image%2020230416232327.png)
如图所示，分段提供了一种机制，将处理器可寻址的内存空间（称为线性地址空间）划分为更小的受保护的地址空间，称为段。段可以用于保存程序的代码、数据和堆栈，也可以用于保存系统数据结构（如 TSS 或 LDT）。如果在处理器上运行多个程序（或任务），则可以为每个程序分配其自己的一组段。然后，处理器强制执行这些段之间的边界，并确保一个程序不会通过写入其他程序的段来干扰另一个程序的执行。分段机制还允许对段进行类型化，以便可以限制可以在特定类型的段上执行的操作。
系统中的所有段都包含在处理器的线性地址空间中。要定位特定段中的字节，必须提供逻辑地址（也称为远指针）。逻辑地址由段选择器和偏移量组成。段选择器是段的唯一标识符。除其他外，它还提供了一个偏移量到一个描述符表（如全局描述符表 GDT）的数据结构的偏移量，称为段描述符。每个段都有一个段描述符，它指定了段的大小、段的访问权限和特权级别、段的类型以及段中第一个字节在线性地址空间中的位置（称为段的基地址）。逻辑地址的偏移部分加上段的基地址可以定位段内的字节。因此，基地址加上偏移量形成处理器线性地址空间中的线性地址。

如果不使用分页，处理器的线性地址空间直接映射到处理器的物理地址空间中。物理地址空间被定义为处理器在地址总线上可以生成的地址范围。
由于多任务计算系统通常定义的线性地址空间比一次性包含在物理内存中经济可行的要大得多，因此需要一种“虚拟化”线性地址空间的方法。这种虚拟化线性地址空间是通过处理器的分页机制处理的。
分页支持“虚拟内存”环境，其中使用少量的物理内存（RAM和ROM）和一些磁盘存储来模拟大型线性地址空间。在使用分页时，每个段被划分为页面（通常每个页面大小为4 KBytes），这些页面存储在物理内存或磁盘上。操作系统或执行器维护一个页目录和一组页表来跟踪这些页面。当程序（或任务）尝试访问线性地址空间中的地址位置时，处理器使用页目录和页表将线性地址转换为物理地址，然后对内存位置执行请求的操作（读取或写入）。
如果正在访问的页面当前不在物理内存中，处理器会中断程序的执行（通过生成页面错误异常）。然后，操作系统或执行器从磁盘中将页面读入物理内存，并继续执行程序。
当操作系统或执行器正确实现分页时，页面在物理内存和磁盘之间的交换对程序的正确执行是透明的。即使是为 16 位 IA-32 处理器编写的程序也可以在虚拟 8086 模式下运行时进行分页（透明地）。

## 3.2 分段
IA-32 体系结构支持的分段机制可以用于实现各种系统设计。这些设计范围从仅最小限度地使用分段来保护程序的平面模型，到使用分段创建强大的操作环境，可在其中可靠地执行多个程序和任务的多分段模型。
### Protected Flat Model
受保护的平面模型类似于基本平面模型，但是段限制设置为仅包括实际存在物理内存的地址范围。任何试图访问不存在的内存的尝试都会生成通用保护异常。这个模型提供了一种最低限度的硬件保护，可以防止某些程序错误。
可以在这个受保护的平面模型中增加更多的复杂性以提供更多的保护。例如，为了使分页机制在用户和监管员代码和数据之间提供隔离，需要定义四个段：特权级别为 3 的用户代码和数据段，以及特权级别为 0 的监管员代码和数据段。通常，这些段都重叠在一起，并从线性地址空间中的地址 0 开始。通过使用简单的分页结构，这种平面分段模型可以保护操作系统免受应用程序的影响，并通过为每个任务或进程添加单独的分页结构，还可以保护应用程序免受彼此的影响。几个流行的多任务操作系统使用类似的设计。
### Multi-Segment Model
一个多段模型利用分段机制的全部功能，提供硬件强制保护代码、数据结构、程序和任务。每个程序（或任务）都有自己的段描述符表和自己的段。这些段可以完全私有于它们所分配的程序，也可以在多个程序之间共享。对于所有段和运行在系统上的单个程序的执行环境的访问都由硬件控制。
### Paging and Segmentation
分页可以与任何分段模型一起使用。处理器的分页机制将线性地址空间（将段映射到其中）划分为页面。然后将这些线性地址空间页面映射到物理地址空间中的页面。分页机制提供了几个页面级别的保护功能，可以与段保护功能一起使用或代替使用。例如，它允许按页面强制执行读写保护。分页机制还提供了两级用户-监管员保护，也可以按页面指定。
## 3.3 逻辑地址和线性地址的转换
在保护模式下的系统架构级别上，处理器使用两个地址转换阶段来到达物理地址：逻辑地址转换和线性地址空间分页。
即使最小化使用段，处理器的地址空间中的每个字节都是通过逻辑地址访问的。逻辑地址由16位段选择器和32位偏移量组成（参见图3-5）。段选择器标识字节所在的段，偏移量指定相对于段基地址的字节位置。
处理器将每个逻辑地址转换为线性地址。线性地址是处理器线性地址空间中的32位地址。与物理地址空间一样，线性地址空间是一个平面（未分段）的2 32字节地址空间，地址范围从0到FFFFFFFFH。线性地址空间包含系统定义的所有段和系统表。
为了将逻辑地址转换为线性地址，处理器执行以下操作：
1.使用段选择器中的偏移量在GDT或LDT中定位段描述符，并将其读入处理器。（仅在将新的段选择器加载到段寄存器时需要执行此步骤。）
2.检查段描述符以检查段的访问权限和范围，以确保段可访问并且偏移量在段的限制内。
3. 将段描述符中的基地址与偏移量相加以形成线性地址。

如果不使用分页，处理器直接将线性地址映射到物理地址（也就是说，线性地址输出到处理器的地址总线上）。如果线性地址空间进行了分页，将使用第二级地址转换来将线性地址转换为物理地址。

### 段选择子
段选择子是一个 16 位的段标识符。它并不直接指向段，而是指向定义该段的段描述符。一个段选择子包含以下内容：
* INDEX 索引（3 至 15 位）- 选择 GDT 或 LDT 中的 8192 个描述符之一。处理器将索引值乘以 8（段描述符中的字节数），并将结果加上 GDT 或 LDT 的基地址（分别来自 GDTR 或 LDTR 寄存器）。
* TI（表指示器）标志（第 2 位）- 指定要使用的描述符表：清除此标志选择 GDT；设置此标志选择当前 LDT。
* Requested Privilege Level (RPL)（位 0 和 1）- 指定选择器的特权级别。特权级别可以从 0 到 3，其中 0 是最高特权级别。有关 RPL 与执行程序（或任务）的 CPL 和段选择子指向的描述符特权级别（DPL）之间关系的描述，请参见第 5.5 节“特权级别”。

处理器不使用GDT的第一个条目。指向GDT的此条目的段选择子（即索引为0且TI标志设置为0的段选择子）用作“空段选择子”。当除CS或SS寄存器以外的段寄存器被加载为空选择器时，处理器不会生成异常。然而，当一个持有空选择器的段寄存器被用于访问内存时，它会生成异常。空选择器可用于初始化未使用的段寄存器。将CS或SS寄存器加载为空段选择器会导致生成通用保护异常（#GP）。
段选择子对应用程序可见，作为指针变量的一部分，但选择器的值通常由链接编辑器或链接加载器分配或修改，而不是应用程序。
### 段寄存器
为了减少地址转换时间和编码复杂性，处理器提供了可容纳最多 6 个段选择子的寄存器（见图 3-7）。这些段寄存器中的每一个都支持特定类型的内存引用（代码、堆栈或数据）。为了实现几乎任何类型的程序执行，至少必须将代码段（CS）、数据段（DS）和堆栈段（SS）寄存器加载为有效的段选择子。处理器还提供了三个额外的数据段寄存器（ES、FS 和 GS），可以用于向当前执行的程序（或任务）提供其他数据段。
要访问一个段，该段的段选择子必须已经加载到其中一个段寄存器中。因此，尽管系统可以定义成千上万个段，但只有6个可以立即使用。在程序执行期间，可以通过将其段选择子加载到这些寄存器中来使其他段可用。
### 段描述符
段描述符是 GDT 或 LDT 中的数据结构，它向处理器提供段的大小和位置，以及访问控制和状态信息。段描述符通常由编译器、链接器、加载器、操作系统或执行体创建，而不是应用程序。图 3-8 说明了所有类型的段描述符的通用描述符格式。
## 3.5 SYSTEM DESCRIPTOR TYPES

当段描述符中的S（描述符类型）标志清除时，描述符类型是系统描述符。处理器识别以下类型的系统描述符：
• 本地描述符表（LDT）段描述符。
• 任务状态段（TSS）描述符。
• 调用门描述符。
• 中断门描述符。
• 陷阱门描述符。
• 任务门描述符。
这些描述符类型分为两类：系统段描述符和门描述符。系统段描述符指向系统段（LDT 和 TSS 段）。门描述符本身就是“门”，它们包含指向代码段中的过程入口点的指针（调用门、中断门和陷阱门），或者包含 TSS 的段选择子（任务门）。
### Segment Descriptor Tables
每个系统必须定义一个 GDT，可用于系统中的所有程序和任务。可选地，可以定义一个或多个 LDT。例如，可以为每个运行的独立任务定义一个 LDT，或者一些或所有任务可以共享同一个 LDT。
GDT本身不是一个段，而是线性地址空间中的数据结构。必须将GDT的基本线性地址和限制加载到GDTR寄存器中（请参见第2.4节“内存管理寄存器”）。GDT的基地址应在8字节边界上对齐，以获得最佳的处理器性能。GDT的限制值以字节为单位表示。与段一样，将限制值加上基地址可得到最后一个有效字节的地址。限制值为0会产生一个有效字节。由于段描述符始终为8个字节长，因此GDT限制应始终是8的整数倍减1（即8N-1）。
处理器不使用GDT中的第一个描述符。指向这个“空描述符”的段选择子在加载到数据段寄存器（DS、ES、FS或GS）中时不会生成异常，但是在尝试使用描述符访问内存时总是会生成通用保护异常（#GP）。通过使用这个段选择子初始化段寄存器，可以保证对未使用的段寄存器的意外引用会生成异常。
LDT位于LDT类型的系统段中。GDT必须包含LDT段的段描述符。如果系统支持多个LDT，则每个LDT必须在GDT中具有单独的段选择子和段描述符。LDT的段描述符可以位于GDT中的任何位置。有关LDT段描述符类型的信息，请参见第3.5节“系统描述符类型”。
使用其段选择子访问LDT。为了在访问LDT时消除地址转换，LDT的段选择子、基本线性地址、限制和访问权限存储在LDTR寄存器中（请参见第2.4节“内存管理寄存器”）。
当存储GDTR寄存器（使用SGDT指令）时，会在内存中存储一个48位的“伪描述符”（请参见图3-11中的顶部图表）。为了避免在用户模式（特权级别3）中发生对齐检查故障，伪描述符应位于奇数字地址处（即，地址MOD 4等于2）。这会导致处理器存储一个对齐的字，后面跟一个对齐的双字。用户模式程序通常不会存储伪描述符，但是通过以这种方式对齐伪描述符可以避免生成对齐检查故障的可能性。存储IDTR寄存器时，应使用相同的对齐方式。当使用SLDT或STR指令存储LDTR或任务寄存器时，伪描述符应位于双字地址处（即，地址MOD 4等于0）。
