## **Rust Tips：`#[derive]`**
通过 `#[derive(...)]` 可以让编译器为你的类型提供一些 Trait 的默认实现。
-   实现了 `Clone` Trait 之后就可以调用 `clone` 函数完成拷贝；
    
-   实现了 `PartialEq` Trait 之后就可以使用 `==` 运算符比较该类型的两个实例，从逻辑上说只有两个相等的应用执行状态才会被判为相等，而事实上也确实如此。
    
-   `Copy` 是一个标记 Trait，决定该类型在按值传参/赋值的时候采用移动语义还是复制语义。



##  `macro_rules!`
在 Rust 中，`macro_rules!` 宏用于定义自定义宏。它允许 Rust 程序员创建代码修改器，允许他们根据需要自定义代码的行为。使用 `macro_rules!` 宏可以将一组模式与 Rust 代码片段相关联并将其替换为其他代码。这可以帮助编程人员通过减少冗长的代码编写并改进代码可读性来加速开发速度。例如，如果您需要使用某种简短的方法执行任务，您可以使用 Rust 宏自动扩展代码以实现该任务，从而消除了每次要进行的机械操作的重复。

##  `format_args!()` 
在 Rust 中，`format_args!($fmt $(, $($arg)+)?)` 是一个宏，用于将参数按照指定的格式进行字符串格式化。具体来说，它接收一个格式字符串 `$fmt` 和可变数量的参数 `$($arg)+`，并返回一个 `std::fmt::Arguments` 类型的值，这个值可以传递给其他打印相关的宏和函数（如 `print!()` 和 `writeln!()` 等）。

使用这个宏的好处是可以避免不必要的字符串分配，因为它将参数和格式字符串封装在一个 `Arguments` 值中，而不是立即将它们拼接为一个字符串。这个 `Arguments` 值可以在需要时再进行分配和格式化，从而提高性能和内存效率。

`format_args!()` 宏是由标准库中的 `format!()` 和 `println!()` 等宏调用的基础，它为这些宏提供了字符串格式化的底层实现。