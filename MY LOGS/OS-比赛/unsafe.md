# Unsafe
**unsafe 真的就是“不安全”吗？**

下面是笔者关于 unsafe 一点较为深入的讨论，不感兴趣的同学可以跳过。

当我们在 Rust 中使用 unsafe 的时候，并不仅仅是为了绕过编译器检查，更是为了告知编译器和其他看到这段代码的程序员：“ **我保证这样做是安全的** ” 。尽管，严格的 Rust 编译器暂时还不能确信这一点。从规范 Rust 代码编写的角度，我们需要尽可能绕过 unsafe ，因为如果 Rust 编译器或者一些已有的接口就可以提供安全性，我们当然倾向于利用它们让我们实现的功能仍然是安全的，可以避免一些无谓的心智负担；反之，就只能使用 unsafe ，同时最好说明如何保证这项功能是安全的。

这里简要从内存安全的角度来分析一下 `PhysPageNum` 的 `get_*` 系列方法的实现中 `unsafe` 的使用。首先需要指出的是，当需要访问一个物理页帧的时候，我们需要从它被绑定到的 `FrameTracker` 中获得其物理页号 `PhysPageNum` 随后再调用 `get_*` 系列方法才能访问物理页帧。因此， `PhysPageNum` 介于 `FrameTracker` 和物理页帧之间，也可以看做拥有部分物理页帧的所有权。由于 `get_*` 返回的是引用，我们可以尝试检查引用引发的常见问题：第一个问题是 use-after-free 的问题，即是否存在 `get_*` 返回的引用存在期间被引用的物理页帧已被回收的情形；第二个问题则是注意到 `get_*` 返回的是可变引用，那么就需要考虑对物理页帧的访问读写冲突的问题。

为了解决这些问题，我们在编写代码的时候需要额外当心。对于每一段 unsafe 代码，我们都需要认真考虑它会对其他无论是 unsafe 还是 safe 的代码造成的潜在影响。比如为了避免第一个问题，我们需要保证当完成物理页帧访问之后便立即回收掉 `get_*` 返回的引用，至少使它不能超出 `FrameTracker` 的生命周期；考虑第二个问题，目前每个 `FrameTracker` 仅会出现一次（在它所属的进程中），因此它只会出现在一个上下文中，也就不会产生冲突。但是当内核态打开（允许）中断时，或内核支持在单进程中存在多个线程时，情况也许又会发生变化。

当编译器不能介入的时候，我们很难完美的解决这些问题。因此重新设计数据结构和接口，特别是考虑数据的所有权关系，将建模进行转换，使得 Rust 有能力检查我们的设计会是一种更明智的选择。这也可以说明为什么要尽量避免使用 unsafe 。事实上，我们目前 `PhysPageNum::get_*` 接口并非一个好的设计，如果同学有兴趣可以试着对设计进行改良，让 Rust 编译器帮助我们解决上述与引用相关的问题。



言归正传， `unsafe` 能赋予我们 5 种超能力，这些能力在安全的 Rust 代码中是无法获取的：

- 解引用裸指针，就如上例所示
- 调用一个 `unsafe` 或外部的函数
- 访问或修改一个可变的[静态变量](https://course.rs/advance/global-variable.html#%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F)
- 实现一个 `unsafe` 特征
- 访问 `union` 中的字段

## [控制 unsafe 的使用边界](https://course.rs/advance/unsafe/intro.html#%E6%8E%A7%E5%88%B6-unsafe-%E7%9A%84%E4%BD%BF%E7%94%A8%E8%BE%B9%E7%95%8C)

`unsafe` 不安全，但是该用的时候就要用，在一些时候，它能帮助我们大幅降低代码实现的成本。

而作为使用者，你的水平决定了 `unsafe` 到底有多不安全，因此你需要在 `unsafe` 中小心谨慎地去访问内存。

即使做到小心谨慎，依然会有出错的可能性，但是 `unsafe` 语句块决定了：就算内存访问出错了，你也能立刻意识到，错误是在 `unsafe` 代码块中，而不花大量时间像无头苍蝇一样去寻找问题所在。

正因为此，写代码时要尽量控制好 `unsafe` 的边界大小，越小的 `unsafe` 越会让我们在未来感谢自己当初的选择。

除了控制边界大小，另一个很常用的方式就是在 `unsafe` 代码块外包裹一层 `safe` 的 API，例如一个函数声明为 safe 的，然后在其内部有一块儿是 `unsafe` 代码